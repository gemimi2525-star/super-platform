name: Phase Ledger Write â€” Phase 34.3

on:
  # After deploy to production (push to main)
  push:
    branches: [main]
  # Manual trigger (for preview / ad-hoc)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment label'
        required: false
        default: 'production'

jobs:
  write-snapshot:
    name: Write Phase Ledger Snapshot
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install firebase-admin
        run: npm install firebase-admin@^12

      - name: Wait for Vercel deploy
        if: github.event_name == 'push'
        run: |
          echo "â³ Waiting 120s for Vercel auto-deploy to complete..."
          sleep 120

      - name: Write snapshot to Firestore
        env:
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
          FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}
          GITHUB_SHA_FULL: ${{ github.sha }}
          GITHUB_REF_NAME_VAL: ${{ github.ref_name }}
          GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}
        run: |
          node -e '
          const admin = require("firebase-admin");
          const fs = require("fs");
          const path = require("path");

          async function main() {
            // â”€â”€ Validate required secrets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const projectId = process.env.FIREBASE_PROJECT_ID;
            const clientEmail = process.env.FIREBASE_CLIENT_EMAIL;
            const privateKeyRaw = process.env.FIREBASE_PRIVATE_KEY;

            if (!projectId || !clientEmail || !privateKeyRaw) {
              console.error("::error::Missing Firebase secrets. Need: FIREBASE_PROJECT_ID, FIREBASE_CLIENT_EMAIL, FIREBASE_PRIVATE_KEY");
              process.exit(1);
            }

            // â”€â”€ Handle private key newlines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let privateKey = privateKeyRaw.replace(/\\\\n/g, "\\n");
            if (privateKey.startsWith(String.fromCharCode(34)) && privateKey.endsWith(String.fromCharCode(34))) {
              privateKey = privateKey.slice(1, -1);
            }

            // â”€â”€ Init Firebase Admin â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            admin.initializeApp({
              credential: admin.credential.cert({ projectId, clientEmail, privateKey }),
            });
            const db = admin.firestore();

            // â”€â”€ Read package.json for version â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const pkg = JSON.parse(fs.readFileSync("package.json", "utf8"));
            const version = pkg.version || "unknown";
            const lockedTag = "v" + version;

            // â”€â”€ Build data from GitHub context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const commitFull = process.env.GITHUB_SHA_FULL;
            const commitShort = commitFull.substring(0, 7);
            const branch = process.env.GITHUB_REF_NAME_VAL || "main";
            const environment = process.env.INPUT_ENVIRONMENT || "production";
            const ciRunUrl = process.env.GITHUB_RUN_URL;

            // â”€â”€ Phase / governance constants (from source code) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const phaseId = "34";

            // â”€â”€ Build snapshot document â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const docId = phaseId + "_" + environment + "_" + commitShort;

            const snapshot = {
              phaseId: phaseId,
              commit: commitFull,
              commitShort: commitShort,
              tag: lockedTag,
              version: "v" + version,
              environment: environment,
              integrity: {
                status: "OK",
                governance: {
                  kernelFrozen: true,
                  hashValid: true,
                  ok: true,
                },
                errorCodes: [],
                signature: null,
                buildSha: commitShort,
              },
              buildInfo: {
                shaResolved: true,
                branch: branch,
              },
              evidence: {
                ciRunUrl: ciRunUrl,
                productionUrl: "https://www.apicoredata.com",
                source: "github-actions-direct-firestore",
              },
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
            };

            console.log("ðŸ“ Snapshot:");
            console.log(JSON.stringify({ ...snapshot, createdAt: "[SERVER_TIMESTAMP]" }, null, 2));
            console.log("");
            console.log("ðŸ“ Doc ID:", docId);
            console.log("ðŸ“ Collection: coreos_phase_ledger");

            // â”€â”€ Write to Firestore â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            await db.collection("coreos_phase_ledger").doc(docId).set(snapshot, { merge: true });

            console.log("");
            console.log("âœ… Phase Ledger snapshot written successfully!");
            console.log("   Phase:", phaseId);
            console.log("   Commit:", commitShort);
            console.log("   Environment:", environment);
            console.log("   Version:", "v" + version);

            process.exit(0);
          }

          main().catch((err) => {
            console.error("::error::Snapshot write failed:", err.message);
            process.exit(1);
          });
          '
