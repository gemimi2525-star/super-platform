# Release: v0.27c-stability

> **APICOREDATA Client OS — Stability Release**  
> **Date:** 2026-02-15  
> **Tag:** v0.27c-stability

---

## Highlights

- **Infra Recovery** — API routes survive Firestore quota exhaustion (503 JSON, not 500 HTML)
- **UI Parity** — Organizations modal + About tab match across Legacy (light) and System Hub (dark)
- **About Parity** — System Hub now has "About" tab showing Architecture Stack (NEXUS → ORBIT → SYNAPSE) and Governance status
- **Quota Reduction** — `Cache-Control: private, max-age=30` on high-read routes; client-side 503 backoff guard

## What's Included

| Component | Change | Commit |
|:----------|:-------|:-------|
| Auth Hardening | `getAuthContext()` quota path → null → 401 | `8b25a43` |
| API Cache Headers | users, orgs, audit routes | `8b25a43` |
| OrganizationsPanel | API base fix + dark modal parity | `8b25a43`, `8debabe` |
| UsersPanel | 503 detection + backoff guard | `8b25a43`, this commit |
| Static Endpoints | `/api/ops/about`, `/api/ops/health/orgs` | `8489a7e`, `7b4521e` |
| About View | System Hub dark-themed About tab | `7b4521e` |
| TTL Cache | In-memory cache with stale-while-revalidate | this commit |
| X-Cache Headers | `X-Cache: HIT/STALE/MISS` on users + orgs routes | this commit |
| Stale Banner | Client-side "last known data" notice on STALE | this commit |
| Health Users | `/api/ops/health/users` static endpoint | this commit |

## Phase 27C.8 — Quota Emergency Mode

**In-memory TTL cache** (`lib/cache/ttl-cache.ts`) wraps Firestore list queries:
- **TTL 30s** — within 30s, no Firestore read at all (`X-Cache: HIT`)
- **Stale window 5min** — if Firestore 503, serves stale data (`X-Cache: STALE`) while background revalidation is attempted
- **Stampede protection** — only one in-flight Firestore query per cache key
- **Mutation invalidation** — POST on users/orgs immediately clears cache

**Response headers:**
- `X-Cache: HIT | STALE | MISS` — cache status
- `X-Cache-Key: users:list | orgs:list` — debug key

**Client-side:** Panels show subtle amber banner "Showing last known data (cache)" when data is served from stale cache.

**Known limitation:** If cache is completely empty AND Firestore quota is exhausted → 503 still occurs. In this case, quota increase or billing plan upgrade is needed.

## Production Evidence — 2026-02-15

**Production SHA:** `753e12d`  
**Deploy confirmed via:** `/api/ops/health/users` → `{ phase: "27C.8" }`

| Gate | Check | Result | Notes |
|:-----|:------|:-------|:------|
| G1a | `/api/ops/health/users` | ✅ 200 JSON | `{ ok: true, service: "users", phase: "27C.8" }` |
| G1b | `/api/ops/health/orgs` | ✅ 200 JSON | `{ ok: true, route: "/api/platform/orgs" }` |
| G2 | X-Cache header presence | ⏳ DEFERRED | Firestore quota exhausted at deploy time — 503 on all data endpoints |
| G3 | X-Cache: HIT (repeated loads) | ⏳ DEFERRED | Requires at least 1 successful Firestore read to populate cache |
| G4 | X-Cache: STALE + amber banner | ⏳ DEFERRED | Requires cache populated before quota exhaustion |
| G5 | Organizations parity (G2–G4) | ⏳ DEFERRED | Same root cause |

**Deferred gates root cause:**  
Firestore Spark plan daily quota was exhausted at the time of deployment. All `/api/platform/*` data endpoints return 503. Since the deploy created new lambda instances (cold start), the TTL cache has no stale data to serve. G2–G5 will become verifiable once Firestore quota resets (next UTC midnight) or billing is upgraded to Blaze.

**Error handling confirmed:** Pages render managed 503 "Quota Exceeded" message instead of crashing (verified via browser screenshot).

## Known Limitations

1. **Vercel Bot Challenge (429):**  
   Direct `curl` to authenticated routes (`/api/platform/*`) may return 429 from Vercel edge bot protection. This is not a system error.  
   **Workaround:** Use browser `fetch()`, or use the static `/api/ops/*` endpoints which do not trigger bot challenge.

2. **Firestore Quota:**  
   If Firestore daily quota is exhausted **and** no cached data exists, API routes return 503 JSON. If cached data exists (within 5min stale window), stale data is served instead. Auth falls back to token-only (no role lookup) to avoid cascading failures.

3. **Cold Start Cache Miss:**  
   New lambda instances start with empty cache. The first request always queries Firestore. Subsequent requests within 30s are served from cache.

## Verification

```bash
# Run all parity gates
bash scripts/post-hotfix-27c.sh

# Expected output: "OVERALL: PASS — all gates green"
```

## No-Touch Zones (Preserved)

- ❌ Auth flow / login / middleware routing — unchanged
- ❌ SYNAPSE Governance Kernel — frozen
- ❌ Legacy "About" component — unchanged
- ❌ No new Firestore reads added (reads significantly reduced via cache)
